'use strict';



// Chat modal functions
function toggleChat() {
    const modal = document.getElementById('chatModal');

    if (!modal) return;

    if (modal.classList.contains('hidden')) {
        openChat();
    } else {
        closeChat();
    }
}

function openChat() {
    const modal = document.getElementById('chatModal');
    const card = document.getElementById('chatCard');
    const toggle = document.getElementById('chatToggle');

    if (!modal || !card) return;

    modal.classList.remove('hidden');

    card.classList.remove('slide-in', 'slide-out');
    card.classList.remove('translate-y-full');

    // Update toggle state
    if (toggle) {
        toggle.checked = true;
    }

    updateApiStatus();

    requestAnimationFrame(() => {
        card.classList.add('slide-in');
    });
}

function closeChat() {
    const modal = document.getElementById('chatModal');
    const card = document.getElementById('chatCard');
    const toggle = document.getElementById('chatToggle');

    if (!modal || !card) return;

    card.classList.remove('slide-in');
    card.classList.add('slide-out');

    // Update toggle state
    if (toggle) {
        toggle.checked = false;
    }

    setTimeout(() => {
        modal.classList.add('hidden');
        card.classList.add('translate-y-full');
        card.classList.remove('slide-out');
    }, 300);
}

// Handle chat toggle from sidebar
function handleChatToggle(checkbox) {
    if (checkbox.checked) {
        openChat();
    } else {
        closeChat();
    }
}

let currentSlide = 0;
const slides = document.querySelectorAll('.slide');
const totalSlides = slides.length;

// Inject navigation below slides
function injectSlideNavigation() {
    if (totalSlides === 0) return;

    // Check if navigation already exists
    if (document.getElementById('slideNavigation')) return;

    // Find the main content wrapper
    const mainWrapper = document.querySelector('.container.mx-auto.px-4.py-8');
    if (!mainWrapper) return;

    // Create navigation container
    const navContainer = document.createElement('div');
    navContainer.id = 'slideNavigation';
    navContainer.className = 'mt-8';
    navContainer.innerHTML = `
        <div class="lg:grid lg:grid-cols-[260px_1fr] gap-8">
            <div class="hidden lg:block"></div>
            <div class="flex justify-between items-center py-6 max-w-5xl">
                <button id="prevSlideBtn" class="btn btn-outline gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
                    </svg>
                    Ïù¥Ï†Ñ
                </button>
                <div class="text-center">
                    <span class="text-sm text-base-content/60"><span id="currentSlideNumber">1</span> / ${totalSlides}</span>
                </div>
                <button id="nextSlideBtn" class="btn btn-primary gap-2">
                    Îã§Ïùå
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                    </svg>
                </button>
            </div>
        </div>
    `;

    // Insert after main wrapper
    mainWrapper.appendChild(navContainer);

    // Add click handlers
    document.getElementById('prevSlideBtn').addEventListener('click', () => changeSlide(-1));
    document.getElementById('nextSlideBtn').addEventListener('click', () => changeSlide(1));
}

// Initialize navigation on page load
if (slides.length > 0) {
    injectSlideNavigation();
}

function showSlide(index, { updateHash = true } = {}) {
    if (index < 0 || index >= totalSlides) return;

    slides.forEach(slide => {
        slide.classList.remove('active');
        slide.classList.remove('animate-fade-in');
    });

    const targetSlide = slides[index];
    targetSlide.classList.add('active');
    targetSlide.classList.add('animate-fade-in');

    currentSlide = index;

    // Update progress bar
    const progress = ((index + 1) / totalSlides) * 100;
    const progressBar = document.getElementById('progressBar');
    if (progressBar) {
        progressBar.style.width = progress + '%';
    }

    // Update sidebar menu
    for (let i = 0; i < totalSlides; i++) {
        const sidebarItem = document.getElementById(`sidebar-slide-${i}`);
        if (sidebarItem) {
            if (i === index) {
                sidebarItem.classList.add('active');
            } else {
                sidebarItem.classList.remove('active');
            }
        }
    }

    // Update pagination
    updatePagination(index);

    if (updateHash) {
        const newHash = `#slide-${index + 1}`;
        if (window.location.hash !== newHash) {
            history.replaceState(null, '', newHash);
        }
    }

    // Scroll to top of page instead of anchor position
    window.scrollTo({ top: 0, behavior: 'smooth' });
}

function updatePagination(index) {
    // Update slide number
    const slideNumber = document.getElementById('currentSlideNumber');
    if (slideNumber) {
        slideNumber.textContent = index + 1;
    }

    // Update button states
    const prevBtn = document.getElementById('prevSlideBtn');
    const nextBtn = document.getElementById('nextSlideBtn');

    if (prevBtn) {
        if (index === 0) {
            prevBtn.disabled = true;
            prevBtn.classList.add('btn-disabled');
        } else {
            prevBtn.disabled = false;
            prevBtn.classList.remove('btn-disabled');
        }
    }

    if (nextBtn) {
        if (index === totalSlides - 1) {
            nextBtn.disabled = true;
            nextBtn.classList.add('btn-disabled');
        } else {
            nextBtn.disabled = false;
            nextBtn.classList.remove('btn-disabled');
        }
    }
}

function changeSlide(direction) {
    const nextIndex = Math.max(0, Math.min(totalSlides - 1, currentSlide + direction));
    showSlide(nextIndex);
}

function goToSlide(index) {
    showSlide(index);
}

function getSlideIndexFromHash() {
    const match = window.location.hash.match(/^#slide-(\d+)$/);
    if (!match) return null;

    const index = parseInt(match[1], 10) - 1;
    if (Number.isNaN(index) || index < 0 || index >= totalSlides) {
        return null;
    }

    return index;
}

function navigateToHash() {
    const index = getSlideIndexFromHash();
    if (index !== null) {
        showSlide(index, { updateHash: false });
    }
}

// Keyboard navigation
document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
        if (themeMenuOpen) {
            closeThemeMenu();
        }
        const modal = document.getElementById('chatModal');
        if (modal && !modal.classList.contains('hidden')) {
            closeChat();
        }
    }
    if (e.key === 'ArrowLeft') changeSlide(-1);
    if (e.key === 'ArrowRight') changeSlide(1);
});

const DEFAULT_API_ENDPOINT = 'https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent';
const DEFAULT_API_MODEL = 'gemini-2.5-flash';

if (window.marked && typeof window.marked.setOptions === 'function') {
    window.marked.setOptions({ breaks: true, gfm: true });
}

const themeDisplayNames = {
    bumblebee: 'üêù Bumblebee',
    silk: 'üé® Silk',
    black: '‚ö´ Black',
    dark: 'üåô Dark',
    light: '‚òÄÔ∏è Light'
};

const themeToggleButton = document.getElementById('themeToggleButton');
const themeMenu = document.getElementById('themeMenu');
let themeMenuOpen = false;

function openThemeMenu() {
    if (!themeMenu || !themeToggleButton) return;
    themeMenu.classList.remove('hidden');
    themeMenuOpen = true;
    themeToggleButton.setAttribute('aria-expanded', 'true');
}

function closeThemeMenu() {
    if (!themeMenu || !themeToggleButton) return;
    themeMenu.classList.add('hidden');
    themeMenuOpen = false;
    themeToggleButton.setAttribute('aria-expanded', 'false');
}

function toggleThemeMenuVisibility() {
    if (themeMenuOpen) {
        closeThemeMenu();
    } else {
        openThemeMenu();
    }
}

function updateThemeLabel(theme) {
    const label = document.getElementById('currentThemeLabel');
    if (!label) return;
    label.textContent = themeDisplayNames[theme] || theme;
}

function getStoredApiSettings() {
    return {
        key: localStorage.getItem('chatApiKey') || '',
        endpoint: localStorage.getItem('chatApiEndpoint') || DEFAULT_API_ENDPOINT,
        model: localStorage.getItem('chatApiModel') || DEFAULT_API_MODEL,
    };
}

function updateApiStatus() {
    const { key } = getStoredApiSettings();
    const isValidated = localStorage.getItem('apiKeyValidated') === 'true';
    const statusText = document.getElementById('apiKeyStatus');
    const button = statusText?.parentElement;
    if (!statusText || !button) return;

    if (key && isValidated) {
        statusText.textContent = 'ÌÇ§ ÏÑ§Ï†ïÎê®';
        button.classList.remove('btn-ghost', 'btn-warning');
        button.classList.add('btn-primary');
    } else if (key && !isValidated) {
        statusText.textContent = 'Í≤ÄÏ¶ù ÌïÑÏöî';
        button.classList.remove('btn-primary', 'btn-ghost');
        button.classList.add('btn-warning');
    } else {
        statusText.textContent = 'ÌÇ§ ÎØ∏ÏÑ§Ï†ï';
        button.classList.remove('btn-primary', 'btn-warning');
        button.classList.add('btn-ghost');
    }
}

function openApiKeyModal() {
    const modal = document.getElementById('apiKeyModal');
    if (!modal) return;

    const { key, endpoint, model } = getStoredApiSettings();

    document.getElementById('apiKeyInput').value = key || '';
    document.getElementById('apiEndpointInput').value = endpoint || '';
    document.getElementById('apiModelInput').value = model || '';

    modal.classList.remove('hidden');
}

function closeApiKeyModal() {
    const modal = document.getElementById('apiKeyModal');
    if (!modal) return;
    modal.classList.add('hidden');
}

async function validateApiKey(key, endpoint, model) {
    if (!key) return { valid: false, error: 'API ÌÇ§Í∞Ä ÏóÜÏäµÎãàÎã§.' };

    try {
        const apiEndpoint = endpoint || DEFAULT_API_ENDPOINT;
        const apiModel = model || DEFAULT_API_MODEL;
        const url = apiEndpoint.replace('{model}', apiModel);

        const response = await fetch(url, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'x-goog-api-key': key
            },
            body: JSON.stringify({
                contents: [{
                    parts: [{ text: 'test' }]
                }]
            })
        });

        if (response.ok) {
            return { valid: true };
        } else {
            const error = await response.text();
            return { valid: false, error: `API ÏùëÎãµ Ïò§Î•ò: ${response.status}` };
        }
    } catch (error) {
        return { valid: false, error: `ÎÑ§Ìä∏ÏõåÌÅ¨ Ïò§Î•ò: ${error.message}` };
    }
}

async function testApiKey() {
    const key = document.getElementById('apiKeyInput').value.trim();
    const endpoint = document.getElementById('apiEndpointInput').value.trim();
    const model = document.getElementById('apiModelInput').value.trim();
    const resultDiv = document.getElementById('apiTestResult');

    if (!key) {
        resultDiv.className = 'alert alert-error text-sm';
        resultDiv.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-5 w-5" fill="none" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
            <span>API ÌÇ§Î•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.</span>
        `;
        resultDiv.classList.remove('hidden');
        return;
    }

    // ÌÖåÏä§Ìä∏ Ï§ë ÌëúÏãú
    resultDiv.className = 'alert alert-info text-sm';
    resultDiv.innerHTML = `
        <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-5 w-5 animate-spin" fill="none" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
        </svg>
        <span>API ÌÇ§ ÌÖåÏä§Ìä∏ Ï§ë...</span>
    `;
    resultDiv.classList.remove('hidden');

    const validation = await validateApiKey(key, endpoint, model);

    if (validation.valid) {
        // Í≤ÄÏ¶ù ÏÑ±Í≥µ Ïãú ÌîåÎûòÍ∑∏ Ï†ÄÏû•
        window.apiKeyValidationSuccess = true;

        resultDiv.className = 'alert alert-success text-sm';
        resultDiv.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-5 w-5" fill="none" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
            <span>‚úÖ API ÌÇ§Í∞Ä Ï†ïÏÉÅÏ†ÅÏúºÎ°ú ÏûëÎèôÌï©ÎãàÎã§!</span>
        `;
    } else {
        window.apiKeyValidationSuccess = false;

        resultDiv.className = 'alert alert-error text-sm';
        resultDiv.innerHTML = `
            <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-5 w-5" fill="none" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
            <span>‚ùå ${validation.error}</span>
        `;
    }
}

function saveApiSettings() {
    const key = document.getElementById('apiKeyInput').value.trim();
    const endpoint = document.getElementById('apiEndpointInput').value.trim();
    const model = document.getElementById('apiModelInput').value.trim();

    if (key) {
        localStorage.setItem('chatApiKey', key);
        // ÌÖåÏä§Ìä∏ ÏÑ±Í≥µÌïú Í≤ΩÏö∞ÏóêÎßå Í≤ÄÏ¶ù ÌîåÎûòÍ∑∏ Ï†ÄÏû•
        if (window.apiKeyValidationSuccess === true) {
            localStorage.setItem('apiKeyValidated', 'true');
        } else {
            localStorage.setItem('apiKeyValidated', 'false');
        }
    } else {
        localStorage.removeItem('chatApiKey');
        localStorage.removeItem('apiKeyValidated');
    }

    if (endpoint) {
        localStorage.setItem('chatApiEndpoint', endpoint);
    } else {
        localStorage.removeItem('chatApiEndpoint');
    }

    if (model) {
        localStorage.setItem('chatApiModel', model);
    } else {
        localStorage.removeItem('chatApiModel');
    }

    updateApiStatus();
    closeApiKeyModal();

    // ÌÖåÏä§Ìä∏ Í≤∞Í≥º Ï¥àÍ∏∞Ìôî
    const resultDiv = document.getElementById('apiTestResult');
    if (resultDiv) {
        resultDiv.classList.add('hidden');
    }
    window.apiKeyValidationSuccess = undefined;
}

// Theme toggle function
function setTheme(theme) {
    const body = document.body;

    // Remove all theme classes
    body.removeAttribute('data-theme');
    document.documentElement.classList.remove('dark');

    // Apply new theme
    if (theme === 'dark') {
        document.documentElement.classList.add('dark');
        localStorage.setItem('theme', 'dark');
    } else {
        body.setAttribute('data-theme', theme);
        localStorage.setItem('theme', theme);
    }

    updateThemeLabel(theme);
}

function applyTheme(theme) {
    setTheme(theme);
    closeThemeMenu();
}

if (themeToggleButton) {
    themeToggleButton.addEventListener('click', (event) => {
        event.stopPropagation();
        toggleThemeMenuVisibility();
    });
}

if (themeMenu) {
    themeMenu.querySelectorAll('[data-theme-option]').forEach((button) => {
        button.addEventListener('click', (event) => {
            const theme = event.currentTarget.getAttribute('data-theme-option');
            if (theme) {
                applyTheme(theme);
            }
        });
    });
}

document.addEventListener('click', (event) => {
    if (!themeMenuOpen) return;
    if (themeMenu && themeMenu.contains(event.target)) return;
    if (themeToggleButton && themeToggleButton.contains(event.target)) return;
    closeThemeMenu();
});

// Initialize theme
const savedTheme = localStorage.getItem('theme') || 'bumblebee';
setTheme(savedTheme);
updateApiStatus();

const initialSlideIndex = getSlideIndexFromHash();
if (initialSlideIndex !== null) {
    showSlide(initialSlideIndex, { updateHash: false });
} else {
    showSlide(0);
}

window.addEventListener('hashchange', navigateToHash);

initCodeCopyButtons();

// Chat Bot Functions

function handleChatKeyPress(event) {
    if (event.key === 'Enter') {
        sendChatMessage();
    }
}

async function sendChatMessage() {
    const input = document.getElementById('chatInput');
    const message = input.value.trim();

    if (!message) return;

    // Add user message
    addChatMessage(message, 'user');
    input.value = '';

    // Get current slide content
    const slideContent = getCurrentSlideContent();
    const settings = getStoredApiSettings();

    if (!settings.key) {
        addChatMessage('API ÌÇ§Í∞Ä ÏÑ§Ï†ïÎêòÏñ¥ ÏûàÏßÄ ÏïäÏäµÎãàÎã§. "API ÌÇ§" Î≤ÑÌäºÏùÑ ÎàåÎü¨ Îì±Î°ùÌï¥ Ï£ºÏÑ∏Ïöî.', 'bot');
        openApiKeyModal();
        return;
    }

    try {
        const response = await callChatApi(message, slideContent, settings);
        addChatMessage(response, 'bot');
    } catch (error) {
        console.error('Chat API error', error);
        addChatMessage('API Ìò∏Ï∂úÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§. Î°úÏª¨ ÏùëÎãµÏúºÎ°ú ÎåÄÏ≤¥Ìï©ÎãàÎã§.', 'bot');
        const fallback = generateBotResponse(message, slideContent);
        addChatMessage(fallback, 'bot');
    }
}

async function callChatApi(message, content, settings) {
    const { key, endpoint, model } = settings;
    if (!key) {
        throw new Error('API_KEY_MISSING');
    }

    const effectiveModel = (model || DEFAULT_API_MODEL).trim() || DEFAULT_API_MODEL;
    const baseEndpoint = (endpoint || DEFAULT_API_ENDPOINT).trim() || DEFAULT_API_ENDPOINT;

    let resolvedEndpoint = baseEndpoint.includes('{model}')
        ? baseEndpoint.replace('{model}', effectiveModel)
        : baseEndpoint;

    if (!resolvedEndpoint.includes(':generateContent')) {
        const normalized = resolvedEndpoint.replace(/\/+$/, '');
        resolvedEndpoint = `${normalized}/${effectiveModel}:generateContent`;
    }

    let requestUrl;
    try {
        requestUrl = new URL(resolvedEndpoint);
    } catch (error) {
        throw new Error('INVALID_ENDPOINT');
    }

    if (!requestUrl.searchParams.has('key')) {
        requestUrl.searchParams.set('key', key);
    }

    const systemPrompt = [
        'Ïó≠Ìï†: CLI ÏõåÌÅ¨ÏàçÏùÑ Ìï®Íªò ÏßÑÌñâÌïòÎäî ÏπúÏ†àÌïú ÏÑ§Î™Ö ÎèÑÏö∞ÎØ∏ÏûÖÎãàÎã§.',
        'Î™©Ìëú:',
        '1) Ï†ÑÎ¨∏ Ïö©Ïñ¥ ÎåÄÏã† Ïâ¨Ïö¥ ÌëúÌòÑÏùÑ ÏÇ¨Ïö©ÌïòÍ≥† Ïã§Ï†ú Î™ÖÎ†πÏñ¥ ÏòàÏãúÎ•º ÎçßÎ∂ôÏûÖÎãàÎã§.',
        '2) ÌïµÏã¨ÏùÑ Îã®Í≥ÑÎ≥ÑÎ°ú ÏöîÏïΩÌïòÍ≥†, ÌïÑÏöîÌïú Í≤ΩÏö∞ Ï£ºÏùòÏÇ¨Ìï≠Ïù¥ÎÇò Ïã§Ïäµ ÌåÅÏùÑ ÏïàÎÇ¥Ìï©ÎãàÎã§.',
        '3) ÎãµÎ≥Ä ÎßàÏßÄÎßâÏóê Ïù¥Ìï¥Í∞Ä ÎêòÏóàÎäîÏßÄ, Ï∂îÍ∞ÄÎ°ú Í∂ÅÍ∏àÌïú Ï†êÏù¥ ÏûàÎäîÏßÄ Ï†ïÏ§ëÌûà ÌôïÏù∏Ìï©ÎãàÎã§.',
        '4) Ïä¨ÎùºÏù¥ÎìúÏóê ÏßÅÏ†ëÏ†ÅÏù∏ Ï†ïÎ≥¥Í∞Ä ÏóÜÎã§Î©¥ Í∑∏ ÏÇ¨Ïã§ÏùÑ Î®ºÏ†Ä ÏïåÎ¶¨Í≥†, ÏùºÎ∞òÏ†ÅÏù∏ ÏßÄÏãù Î≤îÏúÑÏóêÏÑúÎßå ÎèÑÏõÄÏùÑ ÎìúÎ¶ΩÎãàÎã§. ÌôïÏã§ÌïòÏßÄ ÏïäÏùÄ Î∂ÄÎ∂ÑÏùÄ Ï∂îÏ∏°ÌïòÏßÄ ÏïäÏäµÎãàÎã§.'
    ].join('\n');

    const contextDetails = [
        `Ïä¨ÎùºÏù¥Îìú Ï†úÎ™©: ${content.title || 'Ï†úÎ™© ÏóÜÏùå'}`,
        `ÌëúÏãúÎêú Î∞∞ÏßÄ: ${content.badges || 'ÏóÜÏùå'}`,
        `ÏïåÎ¶º: ${content.alerts || 'ÏóÜÏùå'}`,
        `Ï£ºÏöî Ìï≠Î™©: ${content.lists || 'ÏóÜÏùå'}`,
        `ÌòÑÏû¨ Ïä¨ÎùºÏù¥Îìú Î≤àÌò∏: ${content.slideNumber || 'Ïïå Ïàò ÏóÜÏùå'}`
    ].join('\n');

    const userPrompt = [
        'ÏÇ¨Ïö©Ïûê ÏßàÎ¨∏:',
        message,
        '',
        'Ï∞∏Í≥†Ìï† Ïä¨ÎùºÏù¥Îìú Ï†ïÎ≥¥:',
        contextDetails
    ].join('\n');

    const body = {
        contents: [
            {
                role: 'user',
                parts: [{ text: userPrompt }]
            }
        ],
        systemInstruction: {
            role: 'system',
            parts: [{ text: systemPrompt }]
        }
    };

    const response = await fetch(requestUrl.toString(), {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'x-goog-api-key': key
        },
        body: JSON.stringify(body)
    });

    if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`API_ERROR: ${response.status} ${errorText}`);
    }

    const data = await response.json();
    const parts = data?.candidates?.[0]?.content?.parts;
    const text = Array.isArray(parts)
        ? parts.map(part => part?.text || '').join('\n').trim()
        : '';

    if (!text) {
        throw new Error('API_RESPONSE_EMPTY');
    }

    return text;
}

function initCodeCopyButtons() {
    const codeBlocks = document.querySelectorAll('.mockup-code');

    codeBlocks.forEach((block) => {
        if (!block || block.querySelector('.copy-button')) return;

        const codeElement = block.querySelector('code');
        if (!codeElement) return;

        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'btn btn-xs btn-outline copy-button';
        button.textContent = 'Î≥µÏÇ¨';
        button.setAttribute('aria-label', 'ÏΩîÎìú Î≥µÏÇ¨');

        button.addEventListener('click', async () => {
            const originalLabel = 'Î≥µÏÇ¨';
            const successLabel = 'Î≥µÏÇ¨Îê®!';
            const failureLabel = 'Î≥µÏÇ¨ Ïã§Ìå®';
            const textToCopy = codeElement.innerText.replace(/\u00a0/g, ' ');

            const copied = await copyTextToClipboard(textToCopy);

            button.textContent = copied ? successLabel : failureLabel;
            if (copied) {
                button.classList.add('copied');
            }

            setTimeout(() => {
                button.textContent = originalLabel;
                button.classList.remove('copied');
            }, 1800);
        });

        block.appendChild(button);
    });
}

async function copyTextToClipboard(text) {
    if (!text) return false;

    if (navigator.clipboard && typeof navigator.clipboard.writeText === 'function') {
        try {
            await navigator.clipboard.writeText(text);
            return true;
        } catch (error) {
            console.warn('Clipboard API failed, falling back to textarea.', error);
        }
    }

    const textarea = document.createElement('textarea');
    textarea.value = text;
    textarea.setAttribute('readonly', '');
    textarea.style.position = 'fixed';
    textarea.style.top = '-9999px';
    document.body.appendChild(textarea);

    let succeeded = false;
    try {
        textarea.select();
        succeeded = document.execCommand('copy');
    } catch (error) {
        console.error('Textarea copy fallback failed.', error);
        succeeded = false;
    } finally {
        document.body.removeChild(textarea);
    }

    return succeeded;
}

function addChatMessage(message, sender) {
    const messagesContainer = document.getElementById('chatMessages');
    const messageDiv = document.createElement('div');
    const isBot = sender !== 'user';

    messageDiv.className = `chat ${isBot ? 'chat-start' : 'chat-end'}`;

    const bubbleDiv = document.createElement('div');
    bubbleDiv.className = `chat-bubble ${isBot ? 'chat-bubble-primary' : 'chat-bubble-secondary'}`;

    if (isBot) {
        let rendered = message;

        if (window.marked) {
            try {
                rendered = window.marked.parse(message, { breaks: true, gfm: true });
            } catch (error) {
                console.warn('Markdown parsing failed, falling back to plain text.', error);
                rendered = message.replace(/\n/g, '<br>');
            }
        } else {
            rendered = message.replace(/\n/g, '<br>');
        }

        if (window.DOMPurify && typeof window.DOMPurify.sanitize === 'function') {
            rendered = window.DOMPurify.sanitize(rendered);
        }

        bubbleDiv.innerHTML = rendered;
    } else {
        bubbleDiv.textContent = message;
    }

    messageDiv.appendChild(bubbleDiv);
    messagesContainer.appendChild(messageDiv);

    // Scroll to bottom
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
}

function getCurrentSlideContent() {
    const activeSlide = document.querySelector('.slide.active');
    if (!activeSlide) return '';

    // Extract text content from slide
    const title = activeSlide.querySelector('h2')?.textContent || '';
    const badges = Array.from(activeSlide.querySelectorAll('.badge')).map(b => b.textContent).join(', ');
    const alerts = Array.from(activeSlide.querySelectorAll('.alert')).map(a => a.textContent.trim()).join('\n');
    const lists = Array.from(activeSlide.querySelectorAll('li')).map(li => li.textContent.trim()).join('\n');

    return {
        title,
        badges,
        alerts,
        lists,
        slideNumber: currentSlide + 1
    };
}

function generateBotResponse(message, content) {
    const lowerMessage = message.toLowerCase();
    const contains = (...tokens) => tokens.some(token => lowerMessage.includes(token));

    let reply;

    if (contains('open', 'Ïó¥Í∏∞', 'Ïó¥Ïñ¥', 'Î∏åÎùºÏö∞Ï†Ä')) {
        reply = 'open Î™ÖÎ†πÏùÄ ÏõêÌïòÎäî Ïï±Ïù¥ÎÇò URLÏùÑ Ï¶âÏãú Ïã§ÌñâÌï† Îïå ÏîÅÎãàÎã§. ÏòàÎ•º Îì§Ïñ¥ `open -a "Google Chrome"`ÏùÄ ÌÅ¨Î°¨ÏùÑ Ïó¥Í≥†, `open https://example.com`ÏùÄ Ìï¥Îãπ Ïõπ ÌéòÏù¥ÏßÄÎ•º Î∞îÎ°ú ÎùÑÏõÅÎãàÎã§.';
    } else if (contains('ÌååÏùº', 'Ìè¥Îçî', 'mkdir', 'ls', 'mv', 'rm')) {
        reply = 'CLIÏóêÏÑú ÌååÏùºÏùÑ Îã§Î£®Îäî Í∏∞Î≥∏ ÌùêÎ¶ÑÏùÄ ÏúÑÏπò ÌôïÏù∏(pwd), Î™©Î°ù ÌôïÏù∏(ls -la), Í∑∏Î¶¨Í≥† mkdir¬∑cp¬∑mv¬∑rm Í∞ôÏùÄ Î™ÖÎ†πÏúºÎ°ú Ï°∞ÏûëÌïòÎäî Í≤ÉÏûÖÎãàÎã§. Ïù¥ ÌùêÎ¶ÑÎßå ÏùµÌûàÎ©¥ ÎåÄÎ∂ÄÎ∂ÑÏùò ÌååÏùº ÏûëÏóÖÏùÑ Îπ†Î•¥Í≤å Ï≤òÎ¶¨Ìï† Ïàò ÏûàÏäµÎãàÎã§.';
    } else if (contains('ÌååÏù¥ÌîÑ', 'pipe', '|')) {
        reply = 'ÌååÏù¥ÌîÑ(|)Îäî Ïïû Î™ÖÎ†πÏùò Ï∂úÎ†•ÏùÑ Îí§ Î™ÖÎ†πÏùò ÏûÖÎ†•ÏúºÎ°ú ÎÑòÍ∏∞Îäî Ïó∞Í≤∞ Í≥†Î¶¨ÏûÖÎãàÎã§. ÏòàÎ•º Îì§Ïñ¥ `cat log.txt | grep "ERROR"`Ï≤òÎüº Ïó∞Í≤∞ÌïòÎ©¥ ÌïÑÏöîÌïú Ï§ÑÎßå Î∞îÎ°ú Í±∏Îü¨ÎÇº Ïàò ÏûàÏäµÎãàÎã§.';
    } else if (contains('Î¶¨Îã§Ïù¥Î†âÏÖò', 'redirect', '>', '>>')) {
        reply = '`>`Îäî ÏÉà ÌååÏùºÏùÑ ÎßåÎì§Í±∞ÎÇò ÎçÆÏñ¥Ïì∞Í≥†, `>>`Îäî Í∏∞Ï°¥ ÌååÏùº ÎÅùÏóê ÎÇ¥Ïö©ÏùÑ Ïù¥Ïñ¥Î∂ôÏûÖÎãàÎã§. ÏòàÎ•º Îì§Ïñ¥ `echo "Ï≤´ Ï§Ñ" > log.txt`Î°ú ÌååÏùºÏùÑ ÎßåÎì§Í≥† `echo "ÎëòÏß∏ Ï§Ñ" >> log.txt`Î°ú Í≥ÑÏÜç Ï∂îÍ∞ÄÌï† Ïàò ÏûàÏäµÎãàÎã§.';
    } else if (contains('Ïã§Ïäµ', 'ÎØ∏ÏÖò', 'mission')) {
        reply = 'Ïã§Ïäµ ÎØ∏ÏÖòÏùÄ notes/today.md Î©îÎ™® ÎßåÎì§Í∏∞, app.logÏóêÏÑú WARN/ERRORÎßå ÎΩëÏïÑÎÇ¥Í∏∞, Í∑∏Î¶¨Í≥† HTML ÌååÏùºÏùÑ ÎßåÎì§Ïñ¥ Î∏åÎùºÏö∞Ï†ÄÎ°ú ÌôïÏù∏ÌïòÍ∏∞Î°ú Íµ¨ÏÑ±ÎêòÏñ¥ ÏûàÏñ¥Ïöî. ÏßÅÏ†ë ÏÜêÏúºÎ°ú Îî∞Îùº ÌïòÎ©¥ CLI Í∞êÍ∞ÅÏù¥ Ìõ®Ïî¨ Îπ®Î¶¨ ÏÉùÍπÅÎãàÎã§.';
    } else if (contains('ÏπòÌä∏', 'cheat', 'ÏöîÏïΩ')) {
        reply = 'ÏπòÌä∏ÏãúÌä∏ÏóêÎäî Í∞ÄÏû• ÏûêÏ£º Ïì∞Îäî Î™ÖÎ†πÏù¥ Î™®Ïó¨ ÏûàÏäµÎãàÎã§. `pwd`, `ls -la`, `grep`, `ps aux | grep`, `open` Í∞ôÏùÄ Î™ÖÎ†πÏùÑ Ï†ïÎ¶¨Ìï¥ ÎëêÎ©¥ Ïã§Ïäµ Ï§ëÏóê Í≥ßÎ∞îÎ°ú Ï∞∏Í≥†Ìï† Ïàò ÏûàÏñ¥Ïöî.';
    } else if (contains('Ïù¥Ïú†', 'Ïôú', 'reason')) {
        reply = 'ÌÑ∞ÎØ∏ÎÑêÏùÑ Ïì∞Îäî Í∞ÄÏû• ÌÅ∞ Ïù¥Ïú†Îäî Î∞òÎ≥µ ÏûëÏóÖÏùÑ Ìïú Ï§ÑÎ°ú Ï§ÑÏù¥Í≥†, ÏûëÏùÄ ÎèÑÍµ¨Îì§ÏùÑ ÌååÏù¥ÌîÑÎ°ú Ïó∞Í≤∞Ìï¥ Îã§Ïãú Ïì∞Í∏∞ Ïâ¨Ïö¥ ÌòïÌÉúÎ°ú ÎßåÎì§Í∏∞ ÎïåÎ¨∏ÏûÖÎãàÎã§. ÌäπÌûà ÏûêÎèôÌôîÎÇò ÏÑúÎ≤Ñ ÏûëÏóÖÏóêÏÑúÎäî CLIÍ∞Ä Ìõ®Ïî¨ Ìö®Ïú®Ï†ÅÏù¥ÏóêÏöî.';
    } else if (contains('Îã§Ïùå', 'next', 'claude')) {
        reply = 'Îã§Ïùå Îã®Í≥ÑÏóêÏÑúÎäî Claude Code Í∞ôÏùÄ AI ÎèÑÍµ¨ÏôÄ CLIÎ•º Ïó∞Í≤∞Ìï¥, ÌååÏùº ÏÉùÏÑ±¬∑ÏàòÏ†ï¬∑Ïã§ÌñâÏùÑ ÏûêÏó∞Ïñ¥ Î™ÖÎ†πÏúºÎ°ú Ï≤òÎ¶¨ÌïòÎäî ÏõåÌÅ¨ÌîåÎ°úÎ•º ÏÇ¥Ìé¥Î≥¥Î©¥ Ï¢ãÏïÑÏöî.';
    } else {
        switch (content.slideNumber) {
            case 1:
                reply = 'Ï≤´ Ïä¨ÎùºÏù¥ÎìúÎäî Ïù¥Î≤à ÏÑ∏ÏÖòÏùò Î™©ÌëúÎ•º ÏöîÏïΩÌï©ÎãàÎã§. CLIÏùò Ïû•Ï†êÏùÑ Îπ†Î•¥Í≤å Ï≤¥Í∞êÌïòÍ≥†, Î™ÖÎ†πÏùÑ Î†àÍ≥†Ï≤òÎüº Ï°∞Ìï©ÌïòÎäî Í∞êÍ∞ÅÏùÑ ÏùµÌûàÎäî Í≤ÉÏù¥ ÌïµÏã¨Ïù¥ÏóêÏöî.';
                break;
            case 2:
                reply = 'Îëê Î≤àÏß∏ Ïä¨ÎùºÏù¥ÎìúÎäî CLIÏùò Í∞úÎÖêÏùÑ Ï†ïÎ¶¨Ìï©ÎãàÎã§. GUIÎ≥¥Îã§ Î∞òÎ≥µ ÏûëÏóÖÏóê Í∞ïÌïòÍ≥†, Î™ÖÎ†πÏùÑ Ïù¥Ïñ¥ Î∂ôÏó¨ ÏûêÎèôÌôîÌï† Ïàò ÏûàÎã§Îäî Ï†êÏùÑ Í∞ïÏ°∞ÌïòÍ≥† ÏûàÏñ¥Ïöî.';
                break;
            case 3:
                reply = 'ÏÑ∏ Î≤àÏß∏ Ïä¨ÎùºÏù¥ÎìúÎäî `open` Î™ÖÎ†πÏúºÎ°ú Ïï±Ïù¥ÎÇò ÏõπÏùÑ Ï¶âÏãú Ïó¨Îäî Î∞©Î≤ïÏùÑ Î≥¥Ïó¨Ï§çÎãàÎã§. ÌÅ¨Î°¨, VS Code, Finder Îì±ÏùÑ Ìïú Ï§ÑÎ°ú Ïã§ÌñâÌï† Ïàò ÏûàÏñ¥Ïöî.';
                break;
            case 4:
                reply = 'ÎÑ§ Î≤àÏß∏ Ïä¨ÎùºÏù¥ÎìúÎäî Ìè¥Îçî ÎßåÎì§Í∏∞(mkdir), ÌååÏùº Ïù¥Îèô/Î≥µÏÇ¨(cp, mv), ÏÇ≠Ï†ú(rm)Ï≤òÎüº Í∞ÄÏû• Í∏∞Î≥∏Ï†ÅÏù∏ ÌååÏùº Ï°∞Ïûë ÌùêÎ¶ÑÏùÑ Îã§Î£πÎãàÎã§.';
                break;
            case 5:
                reply = 'Îã§ÏÑØ Î≤àÏß∏ Ïä¨ÎùºÏù¥ÎìúÎäî Î¶¨Îã§Ïù¥Î†âÏÖòÍ≥º ÌååÏù¥ÌîÑÏùò Ï°∞Ìï©ÏùÑ ÏÑ§Î™ÖÌï©ÎãàÎã§. Ï∂úÎ†• Í≤∞Í≥ºÎ•º ÌååÏùºÏóê Ï†ÄÏû•ÌïòÍ±∞ÎÇò Îã§Ïùå Î™ÖÎ†πÏúºÎ°ú ÎÑòÍ∏∞Îäî Ìå®ÌÑ¥ÏùÑ Í∏∞ÏñµÌï¥ ÎëêÎ©¥ Ï¢ãÏïÑÏöî.';
                break;
            case 6:
                reply = 'Ïó¨ÏÑØ Î≤àÏß∏ Ïä¨ÎùºÏù¥ÎìúÎäî ÏßßÏùÄ Î™ÖÎ†πÏùÑ Î¨∂Ïñ¥ ÏÉàÎ°úÏö¥ ÏõåÌÅ¨ÌîåÎ°úÎ°ú ÎßåÎìúÎäî ÏòàÏãú(A~C)Î•º Î≥¥Ïó¨Ï§çÎãàÎã§. Î©îÎ™® ÎßåÎì§Í∏∞, HTML ÏÉùÏÑ±, Î°úÍ∑∏ ÌïÑÌÑ∞ÎßÅÏù¥ Ï¢ãÏùÄ ÏòàÏóêÏöî.';
                break;
            case 7:
                reply = 'ÏùºÍ≥± Î≤àÏß∏ Ïä¨ÎùºÏù¥ÎìúÎäî 3Î∂Ñ Îç∞Î™® ÏàúÏÑúÎ•º ÏïàÎÇ¥Ìï©ÎãàÎã§. Ïï± Ïó¥Í∏∞, ÌååÏùº ÏÉùÏÑ±¬∑Ïó¥Í∏∞, ÌååÏù¥ÌîÑ Í≤ÄÏÉâ, ÏûêÎèôÌôî Í∞êÍ∞Å Ï†ÑÎã¨ ÏàúÏúºÎ°ú ÏßÑÌñâÌïòÎ©¥ ÌùêÎ¶ÑÏù¥ Îß§ÎÅÑÎüΩÏäµÎãàÎã§.';
                break;
            case 8:
                reply = 'Ïó¨Îçü Î≤àÏß∏ Ïä¨ÎùºÏù¥ÎìúÎäî ÏßÅÏ†ë Îî∞Îùº ÌïòÎäî Ïã§Ïäµ ÎØ∏ÏÖòÏûÖÎãàÎã§. notes/today.md ÏûëÏÑ±, Î°úÍ∑∏ ÏöîÏïΩ, HTML ÌååÏùº ÎØ∏Î¶¨Î≥¥Í∏∞Î•º Ìï¥Î≥¥Î©¥ CLIÍ∞Ä Í∏àÎ∞© ÏπúÏàôÌï¥Ï†∏Ïöî.';
                break;
            case 9:
                reply = 'ÏïÑÌôâ Î≤àÏß∏ Ïä¨ÎùºÏù¥ÎìúÎäî ‚ÄúÏôú CLIÎ•º Ïì∏Íπå?‚ÄùÏóê ÎåÄÌïú Ìïú Ï§Ñ Ï†ïÎ¶¨ÏôÄ Ï∂îÍ∞Ä ÏÑ§Î™ÖÏùÑ Ï†úÍ≥µÌï©ÎãàÎã§. Î∞òÎ≥µ ÏûëÏóÖÏùÑ Ïä§ÌÅ¨Î¶ΩÌä∏Î°ú Î∞îÍæ∏Îäî Ìö®Ïú®ÏùÑ Í∞ïÏ°∞ÌïòÍ≥† ÏûàÏñ¥Ïöî.';
                break;
            case 10:
                reply = 'Ïó¥ Î≤àÏß∏ Ïä¨ÎùºÏù¥ÎìúÎäî ÏπòÌä∏ÏãúÌä∏ÏûÖÎãàÎã§. ÏûêÏ£º Ïì∞Îäî Î™ÖÎ†πÏùÑ ÌïúÎààÏóê Î™®ÏïÑ ÎëêÏóàÏúºÎãà Ïã§Ïäµ Ï§ë Îã®Ï∂ïÌÇ§Ï≤òÎüº ÌôúÏö©ÌïòÎ©¥ Îê©ÎãàÎã§.';
                break;
            case 11:
                reply = 'ÎßàÏßÄÎßâ Ïä¨ÎùºÏù¥ÎìúÎäî Îã§Ïùå Îã®Í≥ÑÎ°ú Claude CodeÏôÄ CLIÎ•º Ïó∞Í≤∞Ìï¥ ÏûêÎèôÌôîÎ•º ÌôïÏû•ÌïòÏûêÎäî Î©îÏãúÏßÄÎ•º Ï†ÑÌï©ÎãàÎã§.';
                break;
            default:
                reply = 'ÌòÑÏû¨ Ïä¨ÎùºÏù¥ÎìúÏóê ÎÇòÏò® ÎÇ¥Ïö©ÏùÑ Î∞îÌÉïÏúºÎ°ú ÎèÑÏôÄÎìúÎ¶¥Í≤åÏöî. Í∂ÅÍ∏àÌïú Ï†êÏùÑ Ï°∞Í∏à Îçî Íµ¨Ï≤¥Ï†ÅÏúºÎ°ú ÏïåÎ†§Ï£ºÏãúÎ©¥ Ï¢ãÍ≤†Ïñ¥Ïöî!';
        }
    }

    return `${reply}

Ïù¥ ÏÑ§Î™ÖÏù¥ Ïù¥Ìï¥ÎêòÏÖ®ÎÇòÏöî? Îçî Í∂ÅÍ∏àÌïú Ï†êÏù¥ ÏûàÎã§Î©¥ Ìé∏ÌïòÍ≤å ÎßêÏîÄÌï¥Ï£ºÏÑ∏Ïöî.`;
}
